<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Countdown Party</title>
<link rel="stylesheet" href="/static/css/style.css">
</head>
<body class="host-page">

<!-- SCOREBOARD HEADER -->
<header id="scoreboard">
  <div class="score-title">COUNTDOWN</div>
  <div id="score-chips"></div>
  <div id="round-indicator"></div>
</header>

<!-- ROUND SPLASH OVERLAY (hidden by default) -->
<div id="round-splash" class="hidden" onclick="dismissSplash()"></div>

<!-- MAIN GAME AREA -->
<main id="game-area">
  <div id="screen-lobby" class="screen active">
    <h2 class="neon-text">Ready</h2>
    <div id="lobby-controls"></div>
  </div>

  <!-- LETTERS ROUND -->
  <div id="screen-letters" class="screen">
    <div id="letter-tiles" class="tiles"></div>
    <div id="letters-timer" class="timer-display"></div>
    <div id="letters-pick" class="pick-controls">
      <button class="btn-neon" onclick="drawLetter('vowel')">Vowel</button>
      <button class="btn-neon" onclick="drawLetter('consonant')">Consonant</button>
    </div>
    <div id="letters-submit" class="submit-area hidden"></div>
    <div id="letters-results" class="results-area hidden"></div>
  </div>

  <!-- NUMBERS ROUND -->
  <div id="screen-numbers" class="screen">
    <div id="number-tiles" class="tiles"></div>
    <div id="numbers-target" class="target-display"></div>
    <div id="numbers-timer" class="timer-display"></div>
    <div id="numbers-pick" class="pick-controls">
      <label>Large numbers (0-4):
        <input type="number" id="large-count" min="0" max="4" value="1" class="num-input">
      </label>
      <button class="btn-neon" onclick="drawNumbers()">Draw Numbers</button>
    </div>
    <div id="numbers-submit" class="submit-area hidden"></div>
    <div id="numbers-results" class="results-area hidden"></div>
  </div>

  <!-- CONUNDRUM ROUND -->
  <div id="screen-conundrum" class="screen">
    <div id="conundrum-tiles" class="tiles"></div>
    <div id="conundrum-timer" class="timer-display"></div>
    <div id="conundrum-buzz" class="buzz-area hidden"></div>
    <div id="conundrum-results" class="results-area hidden"></div>
  </div>

  <!-- END SCREEN -->
  <div id="screen-end" class="screen">
    <h2 class="neon-text">Game Over</h2>
    <div id="final-scores"></div>
    <button class="btn-neon btn-start" onclick="window.location='/'">New Game</button>
  </div>
</main>

<!-- RULES SIDEBAR (open by default) -->
<aside id="rules-panel">
  <button id="rules-toggle" onclick="toggleRules()">Rules</button>
  <div class="rules-content">
    <div class="difficulty-badge" id="difficulty-badge"></div>
    <h3><span class="rules-icon">ABC</span> Letters</h3>
    <p>Pick 9 letters. Make the longest word. Score = word length. Winner gets a bonus.</p>
    <h3><span class="rules-icon">#</span> Numbers</h3>
    <p>Pick 6 numbers. Hit the target using +, -, *, /. You don't have to use every number.<br>
       Exact = 10 pts<br>Within 5 = 7 pts<br>Within 10 = 5 pts<br>Within 20 = 3 pts</p>
    <h3><span class="rules-icon">?</span> Conundrum</h3>
    <p>Unscramble the anagram. First to buzz in wins 10 points.</p>
  </div>
</aside>

<!-- SOUND TOGGLE -->
<button id="sound-toggle" onclick="toggleSound()" title="Toggle sound">&#9834;</button>

<script>
// --- State ---
let state = {};
let timerInterval = null;
let timerSeconds = 45;
let soundEnabled = false;
let splashTimeout = null;
let currentTarget = null; // for live distance

// --- Audio (Web Audio API for generated tones) ---
let audioCtx = null;
function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function playTick() {
  if (!soundEnabled) return;
  const ctx = getAudioCtx();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.frequency.value = 800;
  osc.type = 'sine';
  gain.gain.value = 0.08;
  osc.start(); osc.stop(ctx.currentTime + 0.05);
}

function playBuzzer() {
  if (!soundEnabled) return;
  const ctx = getAudioCtx();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.frequency.value = 220;
  osc.type = 'square';
  gain.gain.value = 0.15;
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.6);
  osc.start(); osc.stop(ctx.currentTime + 0.6);
}

function toggleSound() {
  soundEnabled = !soundEnabled;
  document.getElementById('sound-toggle').classList.toggle('active', soundEnabled);
  if (soundEnabled) getAudioCtx(); // init on user gesture
}

// --- Init ---
async function init() {
  const resp = await fetch('/api/state');
  state = await resp.json();
  if (!state.teams || state.teams.length === 0) {
    window.location = '/';
    return;
  }
  timerSeconds = state.settings?.timer_seconds || 45;
  const macro = state.settings?.macro || 'medium';
  const badge = document.getElementById('difficulty-badge');
  badge.textContent = macro.charAt(0).toUpperCase() + macro.slice(1) + ' Mode';
  renderScoreboard();
  showLobby();
}

// --- Scoreboard ---
function renderScoreboard() {
  const chips = document.getElementById('score-chips');
  chips.innerHTML = state.teams.map(t =>
    `<div class="score-chip"><span class="team-name">${esc(t)}</span><span class="team-score" id="score-${esc(t)}">${state.scores[t] || 0}</span></div>`
  ).join('');
  updateRoundIndicator();
}

function updateScores() {
  state.teams.forEach(t => {
    const el = document.getElementById(`score-${esc(t)}`);
    if (el) el.textContent = state.scores[t] || 0;
  });
}

function updateRoundIndicator() {
  const el = document.getElementById('round-indicator');
  const seq = state.round_sequence || [];
  if (seq.length === 0) {
    el.textContent = 'Freestyle';
  } else {
    el.textContent = `Round ${Math.min(state.current_round_index + 1, seq.length)} / ${seq.length}`;
  }
}

// --- Screen management ---
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

// ========== ROUND SPLASH ==========
const SPLASH_INFO = {
  letters: {
    label: 'Letters Round',
    scoring: 'Longest word wins.<br>Score = <strong>word length</strong>. Winner gets a <strong>bonus</strong>!'
  },
  numbers: {
    label: 'Numbers Round',
    scoring: 'Hit the target! You don\'t have to use every number.<br>Exact = <strong>10</strong> | Within 5 = <strong>7</strong> | Within 10 = <strong>5</strong> | Within 20 = <strong>3</strong>'
  },
  conundrum: {
    label: 'Conundrum',
    scoring: 'Unscramble the anagram.<br>First to solve wins <strong>10 points</strong>!'
  }
};

function showSplash(type, onDone) {
  const info = SPLASH_INFO[type];
  const macro = state.settings?.macro || 'medium';
  const diffLabel = macro.charAt(0).toUpperCase() + macro.slice(1);
  const el = document.getElementById('round-splash');
  el.innerHTML = `
    <div class="splash-type">${info.label}</div>
    <div class="splash-difficulty">${diffLabel} Mode</div>
    <div class="splash-scoring">${info.scoring}</div>
    <div class="splash-hint">Click anywhere to continue</div>
  `;
  el.classList.remove('hidden');
  el.onclick = () => { dismissSplash(); onDone(); };
  splashTimeout = setTimeout(() => { dismissSplash(); onDone(); }, 5000);
}

function dismissSplash() {
  document.getElementById('round-splash').classList.add('hidden');
  if (splashTimeout) { clearTimeout(splashTimeout); splashTimeout = null; }
}

// --- Lobby ---
function showLobby() {
  const ctrl = document.getElementById('lobby-controls');
  const seq = state.round_sequence || [];
  const idx = state.current_round_index || 0;

  if (seq.length > 0 && idx >= seq.length) {
    showEndScreen();
    return;
  }

  let html = '';
  if (state.settings?.round_mode === 'freestyle' || seq.length === 0) {
    html = `
      <p class="lobby-hint">Choose round type:</p>
      <button class="btn-neon" onclick="startRound('letters')">Letters</button>
      <button class="btn-neon" onclick="startRound('numbers')">Numbers</button>
      <button class="btn-neon btn-conundrum" onclick="startRound('conundrum')">Conundrum</button>
      <button class="btn-neon btn-end" onclick="showEndScreen()">End Game</button>
    `;
  } else {
    const next = seq[idx];
    const label = next.charAt(0).toUpperCase() + next.slice(1);
    html = `
      <p class="lobby-hint">Next: <strong>${label}</strong> round</p>
      <button class="btn-neon btn-start" onclick="startRound('${next}')">Start Round</button>
    `;
  }
  ctrl.innerHTML = html;
  showScreen('screen-lobby');
}

// --- Start round (with splash) ---
async function startRound(type) {
  const resp = await fetch('/api/start_round', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({type})
  });
  const data = await resp.json();
  state.current_round = data.round;

  showSplash(type, () => {
    if (type === 'letters') initLettersRound();
    else if (type === 'numbers') initNumbersRound();
    else if (type === 'conundrum') initConundrumRound();
  });
}

// ========== LETTERS ROUND ==========
function initLettersRound() {
  document.getElementById('letter-tiles').innerHTML = '';
  document.getElementById('letters-timer').textContent = '';
  document.getElementById('letters-pick').classList.remove('hidden');
  document.getElementById('letters-submit').classList.add('hidden');
  document.getElementById('letters-results').classList.add('hidden');
  showScreen('screen-letters');
}

async function drawLetter(kind) {
  const resp = await fetch('/api/draw_letter', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({kind})
  });
  const data = await resp.json();
  renderLetterTiles(data.letters);
  if (data.phase === 'playing') {
    document.getElementById('letters-pick').classList.add('hidden');
    startTimer('letters-timer', () => showLettersSubmit());
  }
}

function renderLetterTiles(letters) {
  const container = document.getElementById('letter-tiles');
  container.innerHTML = letters.map(l =>
    `<div class="tile tile-letter">${l.toUpperCase()}</div>`
  ).join('');
}

function showLettersSubmit() {
  const area = document.getElementById('letters-submit');
  area.classList.remove('hidden');
  area.innerHTML = `<h3>Enter words</h3>` +
    state.teams.map(t =>
      `<div class="submit-row"><label>${esc(t)}:</label><input type="text" id="word-${esc(t)}" class="word-input" maxlength="9" autocomplete="off"></div>`
    ).join('') +
    `<button class="btn-neon" onclick="submitLetters()">Score</button>`;
  const firstInput = area.querySelector('.word-input');
  if (firstInput) firstInput.focus();
}

async function submitLetters() {
  const submissions = {};
  state.teams.forEach(t => {
    const inp = document.getElementById(`word-${esc(t)}`);
    submissions[t] = inp ? inp.value : '';
  });
  const resp = await fetch('/api/submit_letters', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({submissions})
  });
  const data = await resp.json();
  state.scores = data.scores;
  updateScores();
  showLettersResults(data.results, data.reveal);
}

function showLettersResults(results, reveal) {
  document.getElementById('letters-submit').classList.add('hidden');
  const area = document.getElementById('letters-results');
  area.classList.remove('hidden');
  let html = '<h3>Results</h3><div class="results-grid">';
  for (const [team, r] of Object.entries(results)) {
    const cls = r.valid ? 'valid' : 'invalid';
    const err = r.error ? ` <span class="err">(${r.error})</span>` : '';
    const bonus = r.bonus > 0 ? ` <span class="bonus">+${r.bonus} bonus</span>` : '';
    const override = (!r.valid && r.word && r.word !== '-')
      ? ` <button class="btn-neon btn-override" onclick="overrideWord('${esc(team)}')">Override</button>`
      : '';
    html += `<div class="result-row ${cls}" id="result-row-${esc(team)}">
      <span class="team-name">${esc(team)}</span>
      <span class="result-word">${esc(r.word || '-')}${err}${override}</span>
      <span class="result-score">${r.total}${bonus}</span>
    </div>`;
  }
  html += '</div>';

  // Dictionary Geeks Club reveal
  if (reveal) {
    html += '<div class="reveal-section reveal-letters">';
    html += '<div class="reveal-header reveal-geeks-header">THE DICTIONARY GEEKS CLUB</div>';
    const avail = reveal.available_letters || [];

    if (reveal.best_word && reveal.best_word.word) {
      const bw = reveal.best_word;
      const usage = buildLetterUsageMap(bw.letters_used, avail);
      const altText = bw.alternatives_count > 1
        ? ` <span class="reveal-alt">(${bw.alternatives_count} words of this length)</span>` : '';
      html += `<div class="reveal-word-section">
        <div class="reveal-sub-header">Best Word</div>
        <div class="reveal-word">${bw.word.toUpperCase()}</div>
        <div class="reveal-word-meta">${bw.length} letters${altText}</div>
        <div class="reveal-tiles">${renderRevealLetterTiles(usage)}</div>
      </div>`;
    }

    if (reveal.rarest_word && reveal.rarest_word.word) {
      const rw = reveal.rarest_word;
      const usage = buildLetterUsageMap(rw.letters_used, avail);
      html += `<div class="reveal-word-section">
        <div class="reveal-sub-header">Rare Find</div>
        <div class="reveal-word">${rw.word.toUpperCase()}</div>
        <div class="reveal-word-meta">Scrabble value: ${rw.scrabble_score}</div>
        <div class="reveal-tiles">${renderRevealLetterTiles(usage)}</div>
      </div>`;
    }

    html += '</div>';
  }

  html += '<button class="btn-neon" onclick="nextRound()">Continue</button>';
  area.innerHTML = html;
}

async function overrideWord(team) {
  const resp = await fetch('/api/override_word', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({team})
  });
  const data = await resp.json();
  if (data.error) return;
  state.scores = data.scores;
  updateScores();
  showLettersResults(data.results);
}

// ========== NUMBERS ROUND ==========
function initNumbersRound() {
  document.getElementById('number-tiles').innerHTML = '';
  document.getElementById('numbers-target').textContent = '';
  document.getElementById('numbers-timer').textContent = '';
  document.getElementById('numbers-pick').classList.remove('hidden');
  document.getElementById('numbers-submit').classList.add('hidden');
  document.getElementById('numbers-results').classList.add('hidden');
  currentTarget = null;
  showScreen('screen-numbers');
}

async function drawNumbers() {
  const lc = parseInt(document.getElementById('large-count').value) || 1;
  const resp = await fetch('/api/draw_numbers', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({large_count: lc})
  });
  const data = await resp.json();
  currentTarget = data.target;
  renderNumberTiles(data.numbers);
  document.getElementById('numbers-target').innerHTML = `<span class="target-label">TARGET</span><span class="target-number">${data.target}</span>`;
  document.getElementById('numbers-pick').classList.add('hidden');
  startTimer('numbers-timer', () => showNumbersSubmit());
}

function renderNumberTiles(numbers) {
  const container = document.getElementById('number-tiles');
  container.innerHTML = numbers.map((n, i) =>
    `<div class="tile tile-number" data-idx="${i}" data-val="${n}">${n}</div>`
  ).join('');
}

function dimUsedTiles(exprStr) {
  const tiles = document.querySelectorAll('#number-tiles .tile-number');
  tiles.forEach(t => t.classList.remove('tile-used'));
  if (!exprStr || !exprStr.trim()) return;
  // Extract all number literals from expression
  const nums = exprStr.match(/\d+/g);
  if (!nums) return;
  // Build a pool of available tile indices (track which are consumed)
  const available = [];
  tiles.forEach((t, i) => available.push({ idx: i, val: parseInt(t.dataset.val), used: false }));
  // For each number in expression, consume one matching tile
  for (const n of nums) {
    const val = parseInt(n);
    const match = available.find(a => !a.used && a.val === val);
    if (match) {
      match.used = true;
      tiles[match.idx].classList.add('tile-used');
    }
  }
}

function showNumbersSubmit() {
  const area = document.getElementById('numbers-submit');
  area.classList.remove('hidden');
  area.innerHTML = `<h3>Enter expressions</h3>
    <p class="hint">Use +, -, *, / and parentheses. E.g. (75+50)*8+2</p>` +
    state.teams.map(t =>
      `<div class="submit-row">
        <label>${esc(t)}:</label>
        <div style="flex:1">
          <input type="text" id="expr-${esc(t)}" class="expr-input" autocomplete="off" placeholder="e.g. (100+25)*4" oninput="updateLiveDistance('${esc(t)}')">
          <div class="live-distance" id="dist-${esc(t)}"></div>
        </div>
      </div>`
    ).join('') +
    `<button class="btn-neon" onclick="submitNumbers()">Verify & Score</button>`;
  const firstInput = area.querySelector('.expr-input');
  if (firstInput) firstInput.focus();
}

// --- Live distance display ---
function safeEvalExpr(str) {
  // Client-side quick eval for live feedback only (not authoritative)
  try {
    // Allow only digits, operators, parens, spaces
    if (!/^[\d+\-*/() .]+$/.test(str)) return null;
    const result = Function('"use strict"; return (' + str + ')')();
    if (typeof result === 'number' && isFinite(result)) return Math.round(result);
  } catch(e) {}
  return null;
}

function updateLiveDistance(team) {
  const inp = document.getElementById(`expr-${esc(team)}`);
  const el = document.getElementById(`dist-${esc(team)}`);
  if (!inp || !el || currentTarget === null) return;
  const val = inp.value.trim();
  if (!val) { el.textContent = ''; el.className = 'live-distance'; }
  else {
    const result = safeEvalExpr(val);
    if (result === null) {
      el.textContent = '...';
      el.className = 'live-distance dist-error';
    } else {
      const diff = Math.abs(result - currentTarget);
      let cls = 'dist-far';
      if (diff === 0) cls = 'dist-exact';
      else if (diff <= 10) cls = 'dist-close';
      else if (diff <= 20) cls = 'dist-mid';
      el.textContent = `= ${result} (${diff === 0 ? 'EXACT!' : diff + ' away'})`;
      el.className = 'live-distance ' + cls;
    }
  }
  // Dim tiles based on the currently focused team's expression
  dimUsedTiles(inp.value);
}

async function submitNumbers() {
  const submissions = {};
  state.teams.forEach(t => {
    const inp = document.getElementById(`expr-${esc(t)}`);
    submissions[t] = inp ? inp.value : '';
  });
  const resp = await fetch('/api/submit_numbers', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({submissions})
  });
  const data = await resp.json();
  state.scores = data.scores;
  updateScores();
  showNumbersResults(data.results, data.best_solution);
}

function showNumbersResults(results, bestSolution) {
  document.getElementById('numbers-submit').classList.add('hidden');
  const area = document.getElementById('numbers-results');
  area.classList.remove('hidden');
  let html = '<h3>Results</h3><div class="results-grid">';
  for (const [team, r] of Object.entries(results)) {
    const cls = r.error ? 'invalid' : (r.diff === 0 ? 'exact' : 'valid');
    const err = r.error ? ` <span class="err">(${r.error})</span>` : '';
    const val = r.result !== null ? `= ${r.result} (off by ${r.diff})` : 'invalid';
    html += `<div class="result-row ${cls}">
      <span class="team-name">${esc(team)}</span>
      <span class="result-word">${esc(r.expression || '-')} ${val}${err}</span>
      <span class="result-score">${r.score} pts</span>
    </div>`;
  }
  html += '</div>';

  // Best Possible reveal
  if (bestSolution && bestSolution.expression) {
    const distLabel = bestSolution.exact
      ? '<span class="reveal-exact">EXACT!</span>'
      : `<span class="reveal-off">${bestSolution.diff} away</span>`;

    // Build mini-tiles showing which numbers were used
    const usedNums = bestSolution.expression.match(/\d+/g) || [];
    const allTiles = document.querySelectorAll('#number-tiles .tile-number');
    const available = Array.from(allTiles).map(t => ({
      val: parseInt(t.dataset.val), used: false
    }));
    for (const n of usedNums) {
      const val = parseInt(n);
      const match = available.find(a => !a.used && a.val === val);
      if (match) match.used = true;
    }
    const tilesHtml = available.map(a =>
      `<span class="mini-tile mini-tile-number ${a.used ? 'mini-tile-lit' : 'mini-tile-dim'}">${a.val}</span>`
    ).join('');

    html += `<div class="reveal-section reveal-numbers">
      <div class="reveal-header">BEST POSSIBLE</div>
      <div class="reveal-expression">${esc(bestSolution.expression)} = ${bestSolution.result}</div>
      <div class="reveal-distance">${distLabel}</div>
      <div class="reveal-tiles">${tilesHtml}</div>
    </div>`;
  }

  html += '<button class="btn-neon" onclick="nextRound()">Continue</button>';
  area.innerHTML = html;
}

// ========== CONUNDRUM ROUND ==========
let conundrumLives = {};  // { team: livesRemaining }
let conundrumLivesMode = false;
let conundrumBuzzingTeam = null;  // team currently guessing

function initConundrumRound() {
  const rnd = state.current_round;
  const container = document.getElementById('conundrum-tiles');
  container.innerHTML = rnd.anagram.split('').map(l =>
    `<div class="tile tile-conundrum">${l.toUpperCase()}</div>`
  ).join('');
  document.getElementById('conundrum-timer').textContent = '';
  document.getElementById('conundrum-buzz').classList.remove('hidden');
  document.getElementById('conundrum-results').classList.add('hidden');

  conundrumLivesMode = rnd.lives_mode || false;
  conundrumLives = rnd.lives || {};
  conundrumBuzzingTeam = null;

  renderConundrumBuzz();
  showScreen('screen-conundrum');
  startTimer('conundrum-timer', () => conundrumTimeUp());
}

function renderConundrumBuzz() {
  const buzz = document.getElementById('conundrum-buzz');
  if (conundrumLivesMode) {
    // Lives mode: show buzz buttons + lives display
    let html = '<div class="lives-display">';
    state.teams.forEach(t => {
      const lives = conundrumLives[t] || 0;
      const dots = Array(5).fill(0).map((_, i) =>
        `<span class="life-dot ${i < lives ? 'life-full' : 'life-empty'}"></span>`
      ).join('');
      html += `<div class="lives-team"><span class="lives-name">${esc(t)}</span>${dots}</div>`;
    });
    html += '</div>';
    if (conundrumBuzzingTeam) {
      // Show guess input for the buzzing team
      html += `<div class="buzz-guess-area">
        <h3>${esc(conundrumBuzzingTeam)} is guessing...</h3>
        <input type="text" id="conundrum-guess" class="word-input" maxlength="15" autocomplete="off" placeholder="Type the word"
          onkeydown="if(event.key==='Enter')submitConundrumGuess()">
        <button class="btn-neon" onclick="submitConundrumGuess()">Submit</button>
      </div>`;
    } else {
      // Show buzz buttons for teams with lives remaining
      html += `<h3>Buzz in to guess!</h3><div class="buzz-buttons">`;
      state.teams.forEach(t => {
        const lives = conundrumLives[t] || 0;
        if (lives > 0) {
          html += `<button class="btn-neon btn-buzz" onclick="conundrumBuzz('${esc(t)}')">${esc(t)}</button>`;
        } else {
          html += `<button class="btn-neon btn-buzz" disabled style="opacity:0.3">${esc(t)} (out)</button>`;
        }
      });
      html += `</div>`;
      // Check if all teams are out of lives
      const anyAlive = state.teams.some(t => (conundrumLives[t] || 0) > 0);
      if (!anyAlive) {
        html += `<p style="color:var(--gray);margin-top:0.5rem">All teams out of lives!</p>`;
      }
      html += `<button class="btn-neon btn-nobuzz" onclick="conundrumGiveUp()">No one solved it</button>`;
    }
    buzz.innerHTML = html;
    // Auto-focus guess input
    const guessInput = document.getElementById('conundrum-guess');
    if (guessInput) guessInput.focus();
  } else {
    // Classic mode: instant award on buzz
    buzz.innerHTML = `<h3>First to solve -- click their button!</h3>` +
      state.teams.map(t =>
        `<button class="btn-neon btn-buzz" onclick="buzzConundrumClassic('${esc(t)}')">${esc(t)}</button>`
      ).join('') +
      `<button class="btn-neon btn-nobuzz" onclick="buzzConundrumClassic(null)">No one solved it</button>`;
  }
}

function conundrumBuzz(team) {
  // Team buzzed in — show guess input, do NOT stop timer
  conundrumBuzzingTeam = team;
  renderConundrumBuzz();
}

async function submitConundrumGuess() {
  const inp = document.getElementById('conundrum-guess');
  if (!inp) return;
  const guess = inp.value.trim();
  if (!guess) return;
  const team = conundrumBuzzingTeam;
  const resp = await fetch('/api/buzz_conundrum', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({team, guess})
  });
  const data = await resp.json();
  if (data.correct) {
    // Correct! Stop timer and show results
    clearTimer();
    state.scores = data.scores;
    updateScores();
    showConundrumResults(data);
  } else {
    // Wrong — update lives, flash feedback, return to buzz buttons
    conundrumLives = data.lives || conundrumLives;
    conundrumBuzzingTeam = null;
    renderConundrumBuzz();
    // Flash wrong indicator
    const buzz = document.getElementById('conundrum-buzz');
    const flash = document.createElement('div');
    flash.className = 'buzz-wrong-flash';
    flash.textContent = `Wrong! ${esc(team)} loses a life`;
    buzz.prepend(flash);
    setTimeout(() => flash.remove(), 2000);
    // Check if all teams out
    const anyAlive = state.teams.some(t => (conundrumLives[t] || 0) > 0);
    if (!anyAlive) {
      clearTimer();
      conundrumGiveUp();
    }
  }
}

function conundrumTimeUp() {
  // Timer expired — end round with no winner
  conundrumGiveUp();
}

async function conundrumGiveUp() {
  clearTimer();
  const resp = await fetch('/api/submit_conundrum', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({team: null})
  });
  const data = await resp.json();
  state.scores = data.scores;
  updateScores();
  showConundrumResults(data);
}

async function buzzConundrumClassic(team) {
  clearTimer();
  const resp = await fetch('/api/submit_conundrum', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({team})
  });
  const data = await resp.json();
  state.scores = data.scores;
  updateScores();
  showConundrumResults(data);
}

function showConundrumResults(data) {
  document.getElementById('conundrum-buzz').classList.add('hidden');
  const area = document.getElementById('conundrum-results');
  area.classList.remove('hidden');
  const winner = Object.entries(data.results).find(([_, pts]) => pts > 0);
  let html = `<h3>Answer: <span class="neon-text">${data.answer.toUpperCase()}</span></h3>`;
  if (winner) {
    html += `<p class="winner">${esc(winner[0])} wins 10 points!</p>`;
  } else {
    html += `<p>No one solved it.</p>`;
  }
  html += `<button class="btn-neon" onclick="nextRound()">Continue</button>`;
  area.innerHTML = html;
}

// ========== TIMER ==========
function startTimer(elementId, onFinish) {
  clearTimer();
  let remaining = timerSeconds;
  const el = document.getElementById(elementId);
  el.textContent = remaining;
  el.className = 'timer-display timer-running';

  timerInterval = setInterval(() => {
    remaining--;
    el.textContent = remaining;
    playTick();
    if (remaining <= 10) el.classList.add('timer-warning');
    if (remaining <= 5) el.classList.add('timer-critical');
    if (remaining <= 0) {
      clearTimer();
      el.textContent = "TIME";
      el.classList.add('timer-done');
      playBuzzer();
      onFinish();
    }
  }, 1000);
}

function clearTimer() {
  if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
}

// ========== GAME FLOW ==========
async function nextRound() {
  clearTimer();
  const resp = await fetch('/api/next_round', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({})
  });
  const data = await resp.json();
  state.current_round_index = data.round_index;
  state.scores = data.scores;
  updateScores();
  updateRoundIndicator();

  if (data.finished) {
    showEndScreen();
  } else {
    showLobby();
  }
}

function showEndScreen() {
  showScreen('screen-end');
  const el = document.getElementById('final-scores');
  const sorted = Object.entries(state.scores).sort((a, b) => b[1] - a[1]);
  let html = '<div class="final-scores-list">';
  sorted.forEach(([team, score], i) => {
    const cls = i === 0 ? 'winner' : '';
    const crown = i === 0 ? ' ★' : '';
    html += `<div class="final-score-row ${cls}"><span class="team-name">${esc(team)}${crown}</span><span class="team-score">${score}</span></div>`;
  });
  html += '</div>';
  el.innerHTML = html;
}

// ========== RULES ==========
function toggleRules() {
  document.getElementById('rules-panel').classList.toggle('collapsed');
}

// ========== REVEAL HELPERS ==========
function buildLetterUsageMap(usedLetters, availableLetters) {
  const avail = availableLetters.map((l, i) => ({idx: i, letter: l.toLowerCase(), used: false}));
  for (const ul of usedLetters) {
    const match = avail.find(a => !a.used && a.letter === ul.toLowerCase());
    if (match) match.used = true;
  }
  return avail;
}

function renderRevealLetterTiles(usageMap) {
  return usageMap.map(a =>
    `<span class="mini-tile mini-tile-letter ${a.used ? 'mini-tile-lit' : 'mini-tile-dim'}">${a.letter.toUpperCase()}</span>`
  ).join('');
}

// ========== UTIL ==========
function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

// --- Boot ---
init();
</script>
</body>
</html>
